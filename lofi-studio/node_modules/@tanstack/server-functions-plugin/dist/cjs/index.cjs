"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const directiveFunctionsPlugin = require("@tanstack/directive-functions-plugin");
function createTanStackServerFnPlugin(opts) {
  const directiveFnsById = {};
  let viteDevServer;
  const onDirectiveFnsById = (d) => {
    Object.assign(directiveFnsById, d);
    invalidateVirtualModule(
      viteDevServer,
      resolveViteId(opts.manifestVirtualImportId)
    );
  };
  const directive = "use server";
  const directiveLabel = "Server Function";
  return {
    client: [
      // The client plugin is used to compile the client directives
      // and save them so we can create a manifest
      directiveFunctionsPlugin.TanStackDirectiveFunctionsPlugin({
        envLabel: "Client",
        directive,
        directiveLabel,
        getRuntimeCode: opts.client.getRuntimeCode,
        replacer: opts.client.replacer,
        onDirectiveFnsById
      })
    ],
    ssr: [
      // The SSR plugin is used to compile the server directives
      directiveFunctionsPlugin.TanStackDirectiveFunctionsPlugin({
        envLabel: "SSR",
        directive,
        directiveLabel,
        getRuntimeCode: opts.ssr.getRuntimeCode,
        replacer: opts.ssr.replacer,
        onDirectiveFnsById
      })
    ],
    server: [
      {
        // On the server, we need to be able to read the server-function manifest from the client build.
        // This is likely used in the handler for server functions, so we can find the server function
        // by its ID, import it, and call it.
        name: "tanstack-start-server-fn-vite-plugin-manifest-server",
        enforce: "pre",
        configureServer(server) {
          viteDevServer = server;
        },
        resolveId(id) {
          if (id === opts.manifestVirtualImportId) {
            return resolveViteId(id);
          }
          return void 0;
        },
        load(id) {
          if (id !== resolveViteId(opts.manifestVirtualImportId)) {
            return void 0;
          }
          if (this.environment.config.consumer !== "server") {
            return `export default {}`;
          }
          const manifestWithImports = `
          export default {${Object.entries(directiveFnsById).map(
            ([id2, fn]) => `'${id2}': {
                  functionName: '${fn.functionName}',
                  importer: () => import(${JSON.stringify(fn.extractedFilename)})
                }`
          ).join(",")}}`;
          return manifestWithImports;
        }
      },
      // On the server, we need to compile the server functions
      // so they can be called by other server functions.
      // This is also where we split the server function into a separate file
      // so we can load them on demand in the worker.
      directiveFunctionsPlugin.TanStackDirectiveFunctionsPlugin({
        envLabel: "Server",
        directive,
        directiveLabel,
        getRuntimeCode: opts.server.getRuntimeCode,
        replacer: opts.server.replacer,
        onDirectiveFnsById
      })
    ]
  };
}
function TanStackServerFnPluginEnv(opts) {
  opts = {
    ...opts,
    client: {
      ...opts.client,
      envName: opts.client.envName || "client"
    },
    server: {
      ...opts.server,
      envName: opts.server.envName || "server"
    }
  };
  const directiveFnsById = {};
  let viteDevServer;
  const onDirectiveFnsById = (d) => {
    Object.assign(directiveFnsById, d);
    invalidateVirtualModule(
      viteDevServer,
      resolveViteId(opts.manifestVirtualImportId)
    );
  };
  const directive = "use server";
  const directiveLabel = "Server Function";
  return [
    // The client plugin is used to compile the client directives
    // and save them so we can create a manifest
    directiveFunctionsPlugin.TanStackDirectiveFunctionsPluginEnv({
      directive,
      directiveLabel,
      onDirectiveFnsById,
      environments: {
        client: {
          envLabel: "Client",
          getRuntimeCode: opts.client.getRuntimeCode,
          replacer: opts.client.replacer,
          envName: opts.client.envName
        },
        server: {
          envLabel: "Server",
          getRuntimeCode: opts.server.getRuntimeCode,
          replacer: opts.server.replacer,
          envName: opts.server.envName
        }
      }
    }),
    {
      // On the server, we need to be able to read the server-function manifest from the client build.
      // This is likely used in the handler for server functions, so we can find the server function
      // by its ID, import it, and call it. We can't do this in memory here because the builds happen in isolation,
      // so the manifest is like a serialized state from the client build to the server build
      name: "tanstack-start-server-fn-vite-plugin-manifest-server",
      enforce: "pre",
      configureServer(server) {
        viteDevServer = server;
      },
      resolveId: {
        filter: { id: new RegExp(opts.manifestVirtualImportId) },
        handler(id) {
          return resolveViteId(id);
        }
      },
      load: {
        filter: { id: new RegExp(resolveViteId(opts.manifestVirtualImportId)) },
        handler() {
          if (this.environment.config.consumer !== "server") {
            return `export default {}`;
          }
          const manifestWithImports = `
          export default {${Object.entries(directiveFnsById).map(
            ([id, fn]) => `'${id}': {
                  functionName: '${fn.functionName}',
                  importer: () => import(${JSON.stringify(fn.extractedFilename)})
                }`
          ).join(",")}}`;
          return manifestWithImports;
        }
      }
    }
  ];
}
function resolveViteId(id) {
  return `\0${id}`;
}
function invalidateVirtualModule(viteDevServer, resolvedId) {
  if (viteDevServer) {
    const mod = viteDevServer.moduleGraph.getModuleById(resolvedId);
    if (mod) {
      viteDevServer.moduleGraph.invalidateModule(mod);
    }
  }
}
exports.TanStackServerFnPluginEnv = TanStackServerFnPluginEnv;
exports.createTanStackServerFnPlugin = createTanStackServerFnPlugin;
//# sourceMappingURL=index.cjs.map
