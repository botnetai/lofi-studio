import { json } from '@tanstack/start'
import { createAPIFileRoute } from '@tanstack/start/api'

export const APIRoute = createAPIFileRoute('/api/distribution')({
  // Prepare album for distribution
  POST: async ({ request, context }) => {
    const env = context.env as any
    const body = await request.json()
    const { albumId } = body

    if (!albumId) {
      return json({ error: 'Album ID is required' }, { status: 400 })
    }

    try {
      // Get album and songs
      const album = await env.DB.prepare(
        'SELECT * FROM albums WHERE id = ?'
      ).bind(albumId).first()

      if (!album) {
        return json({ error: 'Album not found' }, { status: 404 })
      }

      const songIds = JSON.parse(album.song_ids || '[]')
      const songs = await env.DB.prepare(
        `SELECT * FROM songs WHERE id IN (${songIds.map(() => '?').join(',')}) ORDER BY created_at`
      ).bind(...songIds).all()

      // Prepare distribution metadata
      const distributionData = {
        album: {
          title: album.title,
          artist: album.artist,
          genre: 'Lofi Hip Hop',
          release_date: new Date().toISOString().split('T')[0],
          label: 'Lofi Studio Records',
          copyright: `â„— ${new Date().getFullYear()} ${album.artist}`,
          upc: '', // Would be generated by distribution service
          language: 'Instrumental',
          explicit: false,
          cover_art_url: album.artwork_id ? `/files/artwork/${album.artwork_id}.png` : null
        },
        tracks: songs.results?.map((song: any, index: number) => ({
          title: song.title,
          isrc: '', // Would be generated by distribution service
          duration: song.duration || 180,
          track_number: index + 1,
          disc_number: 1,
          genre: 'Lofi Hip Hop',
          composers: [album.artist],
          lyricists: [],
          producers: ['Lofi Studio AI'],
          performers: [album.artist],
          writers: [album.artist],
          publishers: ['Lofi Studio Publishing'],
          explicit: false,
          instrumental: true,
          audio_file: song.audio_url
        })) || []
      }

      // Update album status
      await env.DB.prepare(
        `UPDATE albums 
         SET status = 'ready', 
             distribution_data = ?,
             updated_at = datetime('now')
         WHERE id = ?`
      ).bind(JSON.stringify(distributionData), albumId).run()

      return json({ 
        success: true, 
        albumId,
        distributionData 
      })
    } catch (error: any) {
      console.error('Distribution preparation error:', error)
      return json({ error: error.message || 'Failed to prepare for distribution' }, { status: 500 })
    }
  },

  // Get distribution-ready albums
  GET: async ({ context }) => {
    const env = context.env as any

    try {
      const albums = await env.DB.prepare(`
        SELECT id, title, artist, created_at, status,
               json_array_length(song_ids) as track_count
        FROM albums 
        WHERE status = 'ready'
        ORDER BY created_at DESC
      `).all()

      return json(albums.results || [])
    } catch (error) {
      console.error('Failed to fetch distribution albums:', error)
      return json({ error: 'Failed to fetch albums' }, { status: 500 })
    }
  }
})